generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  superadmin
  empresa
  medico
  cliente
}

enum AppointmentStatus {
  pending      // cliente agendou, mas sem médico ainda
  scheduled   // já tem médico, aguardando consulta
  cancelled
  completed
  no_show
  rescheduled
}

model User {
  userId   Int     @id @default(autoincrement())
  name     String
  surname  String?
  email    String  @unique
  password String
  role     Role    @default(cliente)

  celular  String?
  whatsapp String?
  nif      String?

  idade  Int?
  genero String?
  crm String?

  empresaId Int?
  empresa   User?  @relation("EmpresaMedicos", fields: [empresaId], references: [userId])
  medicos   User[] @relation("EmpresaMedicos")

  specialties          Specialty[]   @relation("MedicoSpecialties")
  appointmentsAsClient Appointment[] @relation("ClientAppointments")
  appointmentsAsMedico Appointment[] @relation("MedicoAppointments")

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  refreshTokens RefreshToken[]
}

model Specialty {
  specialtyId Int    @id @default(autoincrement())
  name        String

  medicos User[] @relation("MedicoSpecialties")
}

model Appointment {
  appointmentId Int               @id @default(autoincrement())
  startsAt      DateTime
  endsAt        DateTime?
  status        AppointmentStatus @default(pending)
  notes         String?

  clientId Int
  medicoId Int?   // agora é opcional

  client User @relation("ClientAppointments", fields: [clientId], references: [userId])
  medico User? @relation("MedicoAppointments", fields: [medicoId], references: [userId])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

@@unique([medicoId, startsAt])    // impede que o mesmo médico tenha duas consultas no mesmo horário
@@index([medicoId])               // otimiza consultas por médico
@@index([clientId, startsAt])     // otimiza consultas por cliente ordenadas por horário

}



model RefreshToken {
  id        Int      @id @default(autoincrement())
  tokenHash String
  userId    Int
  user      User     @relation(fields: [userId], references: [userId])
  createdAt DateTime @default(now())
  expiresAt DateTime
  revoked   Boolean  @default(false)

  @@index([userId])
}